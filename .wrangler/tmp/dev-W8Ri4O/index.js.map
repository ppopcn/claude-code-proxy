{
  "version": 3,
  "sources": ["../bundle-HnLnY5/checked-fetch.js", "../../../src/index.ts", "../../../../../../../../node-v24.7.0-win-x64/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../../../../../../node-v24.7.0-win-x64/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-HnLnY5/middleware-insertion-facade.js", "../../../../../../../../node-v24.7.0-win-x64/node_modules/wrangler/templates/middleware/common.ts", "../bundle-HnLnY5/middleware-loader.entry.ts"],
  "sourceRoot": "C:\\Users\\Administrator\\Desktop\\code\\claude_proxy\\.wrangler\\tmp\\dev-W8Ri4O",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "/**\r\n * Claude-to-OpenAI API Proxy for Cloudflare Workers\r\n *\r\n * This worker acts as a proxy, converting API requests from the Claude format to the OpenAI format,\r\n * and then converting the responses back. It enables using OpenAI-compatible APIs (like OpenAI,\r\n * Azure OpenAI, Google Gemini, Ollama, etc.) with clients designed for the Claude API.\r\n *\r\n * Features:\r\n * - Full support for the /v1/messages endpoint.\r\n * - Dynamic Routing: Routes requests to any OpenAI-compatible API by embedding the target URL and\r\n * model in the request path. For example, a request to the path\r\n * `/https/api.groq.com/openai/v1/llama3-70b-8192/v1/messages` will be forwarded to the Groq API.\r\n * - Correctly handles and translates tool calls (function calling), including cleaning schemas\r\n * for compatibility with strict APIs like Google Gemini.\r\n * - Supports streaming responses (Server-Sent Events).\r\n * - Dynamically selects API endpoints and keys based on the requested model name (e.g., \"haiku\")\r\n * or the dynamic URL path.\r\n * - Designed for easy deployment on Cloudflare Workers.\r\n */\r\n\r\n// --- TYPE DEFINITIONS ---\r\n\r\n/**\r\n * Environment variables configured in your wrangler.toml or Cloudflare dashboard.\r\n */\r\nexport interface Env {\r\n    /**\r\n     * Pre-configured route for a \"haiku\" model for easier access.\r\n     */\r\n    HAIKU_MODEL_NAME: string;\r\n    HAIKU_BASE_URL: string;\r\n    HAIKU_API_KEY: string;\r\n}\r\n\r\n// --- Claude API Types ---\r\n\r\ninterface ClaudeTool {\r\n    name: string;\r\n    description?: string;\r\n    input_schema: any;\r\n}\r\n\r\ntype ClaudeContent =\r\n    | string\r\n    | Array<{\r\n    type: \"text\" | \"image\" | \"tool_use\" | \"tool_result\";\r\n    text?: string;\r\n    source?: {\r\n        type: \"base64\";\r\n        media_type: string;\r\n        data: string;\r\n    };\r\n    id?: string;\r\n    name?: string;\r\n    input?: any;\r\n    tool_use_id?: string;\r\n    content?: any;\r\n}>;\r\n\r\ninterface ClaudeMessage {\r\n    role: \"user\" | \"assistant\";\r\n    content: ClaudeContent;\r\n}\r\n\r\ninterface ClaudeMessagesRequest {\r\n    model: string;\r\n    messages: ClaudeMessage[];\r\n    system?: string;\r\n    max_tokens: number;\r\n    stop_sequences?: string[];\r\n    stream?: boolean;\r\n    temperature?: number;\r\n    top_p?: number;\r\n    top_k?: number;\r\n    tools?: ClaudeTool[];\r\n    tool_choice?: { type: \"auto\" | \"any\" | \"tool\"; name?: string };\r\n}\r\n\r\n// --- OpenAI API Types ---\r\n\r\ninterface OpenAIMessage {\r\n    role: \"system\" | \"user\" | \"assistant\" | \"tool\";\r\n    content: string | Array<{ type: \"text\" | \"image_url\"; text?: string; image_url?: { url: string } }>;\r\n    tool_calls?: OpenAIToolCall[];\r\n    tool_call_id?: string;\r\n}\r\n\r\ninterface OpenAIToolCall {\r\n    id: string;\r\n    type: \"function\";\r\n    function: {\r\n        name: string;\r\n        arguments: string;\r\n    };\r\n}\r\n\r\ninterface OpenAIRequest {\r\n    model: string;\r\n    messages: OpenAIMessage[];\r\n    max_tokens?: number;\r\n    temperature?: number;\r\n    top_p?: number;\r\n    stop?: string[];\r\n    stream?: boolean;\r\n    tools?: Array<{ type: \"function\"; function: any }>;\r\n    tool_choice?: \"auto\" | \"none\" | { type: \"function\"; function: { name: string } };\r\n}\r\n\r\n// --- Main Worker Logic ---\r\n\r\nexport default {\r\n    async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\r\n        if (request.method === \"OPTIONS\") {\r\n            return handleOptions();\r\n        }\r\n\r\n        const url = new URL(request.url);\r\n        // All valid requests must end with `/v1/messages`.\r\n        if (!url.pathname.endsWith(\"/v1/messages\")) {\r\n            return new Response(\"Not Found. URL must end with /v1/messages\", { status: 404 });\r\n        }\r\n\r\n        if (request.method !== \"POST\") {\r\n            return new Response(\"Method Not Allowed\", { status: 405 });\r\n        }\r\n\r\n        // Claude CLI \u53EF\u80FD\u4E0D\u53D1\u9001\u8BA4\u8BC1\u5934\u90E8\uFF0C\u6211\u4EEC\u4F7F\u7528\u914D\u7F6E\u7684\u5BC6\u94A5\r\n        let effectiveApiKey = request.headers.get('x-api-key') || \r\n                             request.headers.get('anthropic-auth-token') ||\r\n                             request.headers.get('Authorization')?.replace('Bearer ', '');\r\n        \r\n        // \u5982\u679C\u6CA1\u6709\u4ECE\u8BF7\u6C42\u5934\u83B7\u53D6\u5230\u5BC6\u94A5\uFF0C\u4F7F\u7528\u73AF\u5883\u53D8\u91CF\u4E2D\u7684\u5BC6\u94A5\r\n        if (!effectiveApiKey) {\r\n            effectiveApiKey = env.HAIKU_API_KEY;\r\n            console.log('Using fallback API key from environment');\r\n        }\r\n        \r\n        console.log('API Key status:', effectiveApiKey ? 'available' : 'missing');\r\n\r\n        try {\r\n            const claudeRequest: ClaudeMessagesRequest = await request.json();\r\n\r\n            // --- Configuration Selection ---\r\n            let targetApiKey: string = effectiveApiKey;\r\n            let targetModelName: string;\r\n            let targetBaseUrl: string;\r\n\r\n            // Check for the \"haiku\" specific route first.\r\n            const isHaiku = claudeRequest.model.toLowerCase().includes(\"haiku\");\r\n            if (isHaiku) {\r\n                targetModelName = env.HAIKU_MODEL_NAME;\r\n                targetBaseUrl = env.HAIKU_BASE_URL;\r\n                targetApiKey = env.HAIKU_API_KEY; // Use the specific key for Haiku\r\n            } else {\r\n                // Try to parse the base URL and model from the dynamic path.\r\n                const dynamicConfig = parsePathAndModel(url.pathname);\r\n                if (dynamicConfig) {\r\n                    targetBaseUrl = dynamicConfig.baseUrl;\r\n                    targetModelName = dynamicConfig.modelName;\r\n                } else {\r\n                    return new Response(JSON.stringify({ error: 'The \"url\" is missing.' }), {\r\n                        status: 401,\r\n                        headers: { 'Content-Type': 'application/json' },\r\n                    });\r\n                }\r\n            }\r\n\r\n            if (!targetBaseUrl || !targetModelName) {\r\n                return new Response(JSON.stringify({ error: 'Could not determine target base URL or model name. Ensure the URL format is correct or fallback environment variables are set.' }), {\r\n                    status: 400,\r\n                    headers: { 'Content-Type': 'application/json', ...corsHeaders() },\r\n                });\r\n            }\r\n\r\n            const target = {\r\n                modelName: targetModelName,\r\n                baseUrl: targetBaseUrl,\r\n                apiKey: targetApiKey,\r\n            };\r\n\r\n            console.log('Target config:', {\r\n                modelName: target.modelName,\r\n                baseUrl: target.baseUrl,\r\n                apiKeyPrefix: target.apiKey?.substring(0, 10) + '...'\r\n            });\r\n\r\n            const openaiRequest = convertClaudeToOpenAIRequest(claudeRequest, target.modelName);\r\n            \r\n            console.log('Converted OpenAI request:', {\r\n                model: openaiRequest.model,\r\n                messagesCount: openaiRequest.messages?.length,\r\n                maxTokens: openaiRequest.max_tokens\r\n            });\r\n\r\n            const openaiApiResponse = await fetch(`${target.baseUrl}/chat/completions`, {\r\n                method: \"POST\",\r\n                headers: {\r\n                    \"Content-Type\": \"application/json\",\r\n                    Authorization: `Bearer ${target.apiKey}`,\r\n                },\r\n                body: JSON.stringify(openaiRequest),\r\n            });\r\n\r\n            console.log('NVIDIA API response:', {\r\n                status: openaiApiResponse.status,\r\n                statusText: openaiApiResponse.statusText,\r\n                ok: openaiApiResponse.ok\r\n            });\r\n\r\n            if (!openaiApiResponse.ok) {\r\n                const errorBody = await openaiApiResponse.text();\r\n                console.log('NVIDIA API error:', errorBody);\r\n                return new Response(errorBody, {\r\n                    status: openaiApiResponse.status,\r\n                    statusText: openaiApiResponse.statusText,\r\n                    headers: { 'Content-Type': 'application/json', ...corsHeaders() },\r\n                });\r\n            }\r\n\r\n            if (claudeRequest.stream) {\r\n                const transformStream = new TransformStream({\r\n                    transform: streamTransformer(claudeRequest.model),\r\n                });\r\n                return new Response(openaiApiResponse.body!.pipeThrough(transformStream), {\r\n                    headers: { \"Content-Type\": \"text/event-stream\", ...corsHeaders() },\r\n                });\r\n            } else {\r\n                const openaiResponse = await openaiApiResponse.json();\r\n                const claudeResponse = convertOpenAIToClaudeResponse(openaiResponse, claudeRequest.model);\r\n                return new Response(JSON.stringify(claudeResponse), {\r\n                    headers: { \"Content-Type\": \"application/json\", ...corsHeaders() },\r\n                });\r\n            }\r\n        } catch (e: any) {\r\n            return new Response(JSON.stringify({ error: e.message }), {\r\n                status: 500,\r\n                headers: { \"Content-Type\": \"application/json\", ...corsHeaders() },\r\n            });\r\n        }\r\n    },\r\n};\r\n\r\n// ======================= Helper Functions =======================\r\n\r\n/**\r\n * Parses the model and base URL from the request pathname.\r\n * The path is expected to be in the format: /<scheme>/<host>/.../<model_name>/v1/messages\r\n * or /<host>/.../<model_name>/v1/messages (defaulting to https).\r\n * @param pathname The URL pathname from the request.\r\n * @returns An object with `baseUrl` and `modelName`, or `null` if the path doesn't contain a dynamic configuration.\r\n */\r\nfunction parsePathAndModel(pathname: string): { baseUrl: string; modelName: string } | null {\r\n    // Remove the mandatory suffix to isolate the dynamic parts of the path.\r\n    const dynamicPath = pathname.substring(0, pathname.lastIndexOf('/v1/messages'));\r\n    const parts = dynamicPath.split('/').filter(p => p);\r\n\r\n    if (parts.length < 2) {\r\n        // Not enough parts for a dynamic configuration.\r\n        // This occurs for requests to the root `/v1/messages`.\r\n        return null;\r\n    }\r\n\r\n    // The last part of the dynamic path is the model name.\r\n    const modelName = parts.pop()!;\r\n    let baseUrl: string;\r\n\r\n    // Reconstruct the base URL from the remaining parts.\r\n    if (parts[0].toLowerCase() === 'http' || parts[0].toLowerCase() === 'https') {\r\n        const scheme = parts.shift()!;\r\n        baseUrl = `${scheme}://${parts.join('/')}`;\r\n    } else {\r\n        // If no scheme is provided, default to https.\r\n        baseUrl = `https://${parts.join('/')}`;\r\n    }\r\n\r\n    return { baseUrl, modelName };\r\n}\r\n\r\n/**\r\n * Recursively cleans a JSON Schema to make it compatible with target APIs like Google Gemini.\r\n * - Removes '$schema' and 'additionalProperties' keys.\r\n * - For properties of type 'string', removes the 'format' field unless it's 'date-time' or 'enum'.\r\n * @param schema The schema object to clean.\r\n */\r\nfunction recursivelyCleanSchema(schema: any): any {\r\n    if (schema === null || typeof schema !== 'object') {\r\n        return schema;\r\n    }\r\n\r\n    if (Array.isArray(schema)) {\r\n        return schema.map(item => recursivelyCleanSchema(item));\r\n    }\r\n\r\n    const newSchema: { [key: string]: any } = {};\r\n    for (const key in schema) {\r\n        if (Object.prototype.hasOwnProperty.call(schema, key)) {\r\n            if (key === '$schema' || key === 'additionalProperties') {\r\n                continue;\r\n            }\r\n            newSchema[key] = recursivelyCleanSchema(schema[key]);\r\n        }\r\n    }\r\n\r\n    if (newSchema.type === 'string' && newSchema.format) {\r\n        const supportedFormats = ['date-time', 'enum'];\r\n        if (!supportedFormats.includes(newSchema.format)) {\r\n            delete newSchema.format;\r\n        }\r\n    }\r\n\r\n    return newSchema;\r\n}\r\n\r\n/**\r\n * Converts a Claude API request to the OpenAI format.\r\n */\r\nfunction convertClaudeToOpenAIRequest(\r\n    claudeRequest: ClaudeMessagesRequest,\r\n    modelName: string\r\n): OpenAIRequest {\r\n    const openaiMessages: OpenAIMessage[] = [];\r\n\r\n    if (claudeRequest.system) {\r\n        openaiMessages.push({ role: \"system\", content: claudeRequest.system });\r\n    }\r\n\r\n    for (let i = 0; i < claudeRequest.messages.length; i++) {\r\n        const message = claudeRequest.messages[i];\r\n        if (message.role === 'user') {\r\n            if (Array.isArray(message.content)) {\r\n                const toolResults = message.content.filter(c => c.type === 'tool_result');\r\n                const otherContent = message.content.filter(c => c.type !== 'tool_result');\r\n\r\n                if (toolResults.length > 0) {\r\n                    toolResults.forEach(block => {\r\n                        openaiMessages.push({\r\n                            role: 'tool',\r\n                            tool_call_id: block.tool_use_id!,\r\n                            content: typeof block.content === 'string' ? block.content : JSON.stringify(block.content),\r\n                        });\r\n                    });\r\n                }\r\n\r\n                if (otherContent.length > 0) {\r\n                    openaiMessages.push({ role: \"user\", content: otherContent.map(block => block.type === 'text' ? {type: 'text', text: block.text} : {type: 'image_url', image_url: {url: `data:${block.source!.media_type};base64,${block.source!.data}`}} ) as any});\r\n                }\r\n            } else {\r\n                openaiMessages.push({ role: \"user\", content: message.content });\r\n            }\r\n        } else if (message.role === 'assistant') {\r\n            const textParts: string[] = [];\r\n            const toolCalls: OpenAIToolCall[] = [];\r\n            if (Array.isArray(message.content)) {\r\n                message.content.forEach(block => {\r\n                    if (block.type === 'text') {\r\n                        textParts.push(block.text!);\r\n                    } else if (block.type === 'tool_use') {\r\n                        toolCalls.push({\r\n                            id: block.id!,\r\n                            type: 'function',\r\n                            function: { name: block.name!, arguments: JSON.stringify(block.input || {}) },\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n            const assistantMessage: OpenAIMessage = { role: 'assistant', content: textParts.join('\\n') || null as any};\r\n            if (toolCalls.length > 0) {\r\n                assistantMessage.tool_calls = toolCalls;\r\n            }\r\n            openaiMessages.push(assistantMessage);\r\n        }\r\n    }\r\n\r\n    const openaiRequest: OpenAIRequest = {\r\n        model: modelName,\r\n        messages: openaiMessages,\r\n        max_tokens: claudeRequest.max_tokens,\r\n        temperature: claudeRequest.temperature,\r\n        top_p: claudeRequest.top_p,\r\n        stream: claudeRequest.stream,\r\n        stop: claudeRequest.stop_sequences,\r\n    };\r\n\r\n    if (claudeRequest.tools) {\r\n        openaiRequest.tools = claudeRequest.tools.map((tool) => {\r\n            const cleanedParameters = recursivelyCleanSchema(tool.input_schema);\r\n            return {\r\n                type: \"function\",\r\n                function: {\r\n                    name: tool.name,\r\n                    description: tool.description,\r\n                    parameters: cleanedParameters,\r\n                },\r\n            };\r\n        });\r\n    }\r\n\r\n    if (claudeRequest.tool_choice) {\r\n        if (claudeRequest.tool_choice.type === 'auto' || claudeRequest.tool_choice.type === 'any') {\r\n            openaiRequest.tool_choice = 'auto';\r\n        } else if (claudeRequest.tool_choice.type === 'tool') {\r\n            openaiRequest.tool_choice = { type: 'function', function: { name: claudeRequest.tool_choice.name! }};\r\n        }\r\n    }\r\n\r\n    return openaiRequest;\r\n}\r\n\r\n/**\r\n * Converts a non-streaming OpenAI response to the Claude format.\r\n */\r\nfunction convertOpenAIToClaudeResponse(openaiResponse: any, model: string): any {\r\n    const choice = openaiResponse.choices[0];\r\n    const contentBlocks: any[] = [];\r\n    if (choice.message.content) {\r\n        contentBlocks.push({ type: 'text', text: choice.message.content });\r\n    }\r\n    if (choice.message.tool_calls) {\r\n        choice.message.tool_calls.forEach((call: OpenAIToolCall) => {\r\n            contentBlocks.push({\r\n                type: 'tool_use',\r\n                id: call.id,\r\n                name: call.function.name,\r\n                input: JSON.parse(call.function.arguments),\r\n            });\r\n        });\r\n    }\r\n    const stopReasonMap: Record<string, string> = { stop: \"end_turn\", length: \"max_tokens\", tool_calls: \"tool_use\" };\r\n    return {\r\n        id: openaiResponse.id,\r\n        type: \"message\",\r\n        role: \"assistant\",\r\n        model: model,\r\n        content: contentBlocks,\r\n        stop_reason: stopReasonMap[choice.finish_reason] || \"end_turn\",\r\n        usage: {\r\n            input_tokens: openaiResponse.usage.prompt_tokens,\r\n            output_tokens: openaiResponse.usage.completion_tokens,\r\n        },\r\n    };\r\n}\r\n\r\n/**\r\n * Creates a transform function for the streaming response.\r\n */\r\nfunction streamTransformer(model: string) {\r\n    let initialized = false;\r\n    let buffer = \"\";\r\n    const messageId = `msg_${Math.random().toString(36).substr(2, 9)}`;\r\n    const toolCalls: { [index: number]: { id: string, name: string, args: string, claudeIndex: number, started: boolean } } = {};\r\n    let contentBlockIndex = 0;\r\n    const encoder = new TextEncoder();\r\n    const decoder = new TextDecoder();\r\n    const sendEvent = (controller: TransformStreamDefaultController, event: string, data: object) => {\r\n        controller.enqueue(encoder.encode(`event: ${event}\\ndata: ${JSON.stringify(data)}\\n\\n`));\r\n    };\r\n    return (chunk: Uint8Array, controller: TransformStreamDefaultController) => {\r\n        if (!initialized) {\r\n            sendEvent(controller, 'message_start', { type: 'message_start', message: { id: messageId, type: 'message', role: 'assistant', model, content: [], stop_reason: null, usage: { input_tokens: 0, output_tokens: 0 } } });\r\n            sendEvent(controller, 'content_block_start', { type: 'content_block_start', index: 0, content_block: { type: 'text', text: '' } });\r\n            initialized = true;\r\n        }\r\n        buffer += decoder.decode(chunk, { stream: true });\r\n        const lines = buffer.split(\"\\n\");\r\n        buffer = lines.pop() || \"\";\r\n        for (const line of lines) {\r\n            if (!line.startsWith(\"data: \")) continue;\r\n            const data = line.substring(6);\r\n            if (data.trim() === \"[DONE]\") {\r\n                sendEvent(controller, 'content_block_stop', { type: 'content_block_stop', index: 0 });\r\n                Object.values(toolCalls).forEach(tc => {\r\n                    if(tc.started) sendEvent(controller, 'content_block_stop', { type: 'content_block_stop', index: tc.claudeIndex });\r\n                });\r\n                let finalStopReason = \"end_turn\";\r\n                try {\r\n                    const lastChunk = JSON.parse(lines[lines.length - 2].substring(6));\r\n                    const finishReason = lastChunk.choices[0].finish_reason;\r\n                    if (finishReason === 'tool_calls') finalStopReason = 'tool_use';\r\n                    if (finishReason === 'length') finalStopReason = 'max_tokens';\r\n                } catch {}\r\n                sendEvent(controller, 'message_delta', { type: 'message_delta', delta: { stop_reason: finalStopReason, stop_sequence: null }, usage: { output_tokens: 0 } });\r\n                sendEvent(controller, 'message_stop', { type: 'message_stop' });\r\n                controller.terminate();\r\n                return;\r\n            }\r\n            try {\r\n                const openaiChunk = JSON.parse(data);\r\n                const delta = openaiChunk.choices[0]?.delta;\r\n                if (!delta) continue;\r\n                if (delta.content) {\r\n                    sendEvent(controller, 'content_block_delta', { type: 'content_block_delta', index: 0, delta: { type: 'text_delta', text: delta.content } });\r\n                }\r\n                if (delta.tool_calls) {\r\n                    for(const tc_delta of delta.tool_calls) {\r\n                        const index = tc_delta.index;\r\n                        if (!toolCalls[index]) {\r\n                            toolCalls[index] = { id: '', name: '', args: '', claudeIndex: 0, started: false };\r\n                        }\r\n                        if (tc_delta.id) toolCalls[index].id = tc_delta.id;\r\n                        if (tc_delta.function?.name) toolCalls[index].name = tc_delta.function.name;\r\n                        if (tc_delta.function?.arguments) toolCalls[index].args += tc_delta.function.arguments;\r\n                        if (toolCalls[index].id && toolCalls[index].name && !toolCalls[index].started) {\r\n                            contentBlockIndex++;\r\n                            toolCalls[index].claudeIndex = contentBlockIndex;\r\n                            toolCalls[index].started = true;\r\n                            sendEvent(controller, 'content_block_start', { type: 'content_block_start', index: contentBlockIndex, content_block: { type: 'tool_use', id: toolCalls[index].id, name: toolCalls[index].name, input: {} } });\r\n                        }\r\n                        if (toolCalls[index].started && tc_delta.function?.arguments) {\r\n                            sendEvent(controller, 'content_block_delta', { type: 'content_block_delta', index: toolCalls[index].claudeIndex, delta: { type: 'input_json_delta', partial_json: tc_delta.function.arguments } });\r\n                        }\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                // Ignore JSON parse errors\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// --- CORS Handling ---\r\n\r\nfunction corsHeaders() {\r\n    return {\r\n        'Access-Control-Allow-Origin': '*',\r\n        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\r\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization, x-api-key, Anthropic-Version',\r\n    };\r\n}\r\n\r\nfunction handleOptions() {\r\n    return new Response(null, { headers: corsHeaders() });\r\n}\r\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\code\\\\claude_proxy\\\\src\\\\index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"C:\\\\node-v24.7.0-win-x64\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"C:\\\\node-v24.7.0-win-x64\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\code\\\\claude_proxy\\\\src\\\\index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\code\\\\claude_proxy\\\\.wrangler\\\\tmp\\\\bundle-HnLnY5\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"C:\\\\node-v24.7.0-win-x64\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\code\\\\claude_proxy\\\\.wrangler\\\\tmp\\\\bundle-HnLnY5\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\code\\\\claude_proxy\\\\.wrangler\\\\tmp\\\\bundle-HnLnY5\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
